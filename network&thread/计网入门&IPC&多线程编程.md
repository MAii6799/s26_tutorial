# 计算机网络基础与Linux网络编程详解

---

## 一、计算机网络入门
(以下为方便理解举的例子，并非真实发展情况)




最初，计算机都是孤立运行的，彼此之间无法交流。为了让两台计算机能够交换数据，工程师们发明了**网线**，通过物理连接实现点对点通信。最早的网络就是两台计算机用一根网线直接相连，这种方式只能实现最基础的数据传输。

随着需求的增加，出现了**集线器（Hub）**。集线器可以让多台计算机通过一根主线连接在一起，组成一个小型的**局域网（LAN）**，实现了小范围内的资源共享。但集线器只能广播数据，效率较低。具体来说，集线器收到一台电脑发来的数据后，会把数据复制并发送到所有端口，所有电脑都能收到，无论是不是目标。这会造成带宽浪费和安全隐患。

后来，**交换机（Switch）**被发明出来。交换机的工作原理比集线器更智能：它能识别每台电脑的**MAC地址**（网卡的物理地址），并在内部维护一张“MAC地址表”。当某台电脑第一次发送数据时，交换机会记录下该电脑的MAC地址和对应的端口。以后有数据要发给某个MAC地址时，交换机会查表，只把数据发到目标电脑所在的端口，其他端口不会收到。这样既提高了网络效率，也提升了安全性。

当需要连接不同的局域网时，**路由器（Router）**应运而生。路由器的作用是连接多个网络，并根据**IP地址**来决定数据包的转发路径。它内部维护着一张“路由表”，记录哪些IP地址段应该从哪个端口转发出去。当数据包到达路由器时，路由器会查找目标IP地址，决定把数据包发往哪个网络。这样，不同局域网之间的数据就能正确传递，最终实现全球互联。最终，全球无数网络通过路由器和各种通信线路连接，形成了我们今天所说的**互联网（Internet）** 🌐。

举个例子：假如你在中国，要向美国的一位朋友发送一份数据（比如发一封邮件），你的数据包是如何找到正确路径并最终送达对方电脑的呢？

1. **本地网络**  
   首先，你的电脑会把数据包交给本地的路由器。路由器会查看数据包的目标IP地址，判断这个地址是否在本地局域网内。如果不是，就会把数据包转发到上一级网络（通常是运营商的网络）。

2. **运营商网络**  
   你的数据包进入运营商的核心网络。运营商的路由器会继续查找目标IP地址，决定下一跳应该发往哪里。每个路由器内部都有一张“路由表”，记录着哪些IP地址段应该从哪个端口转发出去。

3. **跨国传输**  
   当数据包需要跨越国界时，会经过多个大型骨干路由器和海底光缆。每经过一个路由器，都会查找目标IP地址，并根据最优路径把数据包转发到下一个路由器。这个过程可能会经过很多国家和地区的网络设备。

4. **目标国家的运营商**  
   数据包到达美国后，会被当地运营商的路由器接收，再根据目标IP地址继续转发，逐步靠近目标用户所在的城市和局域网。

5. **目标用户的本地网络**  
   最后，数据包到达你朋友的本地路由器，再由路由器转发到他电脑上。这样，数据就准确无误地送达了。

整个过程中，每一台路由器都只需要知道“下一跳”该往哪里发，而不需要知道完整的路径。正是因为有了分层的路由和动态的路径选择，互联网才能高效地把数据从世界的任何一个角落，准确地送到另一个角落。

---

## 二、网络基础概念

- ## 1. **IP地址**： 
- IP地址（Internet Protocol Address）是分配给网络中每台设备的唯一标识，就像现实生活中的门牌号。常见的IPv4地址由4个0~255之间的数字组成，用点分隔，例如：192.168.1.100。
-  ###### 内网IP与外网IP

有些IP地址是专门保留给局域网（内网）使用的，不能直接在互联网中路由，这些叫**内网IP**。常见的内网IP地址段有：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

只要IP地址在这些范围内，就是内网IP，否则就是外网（公网）IP。

## 2.子网掩码

**子网掩码**（Subnet Mask）用来区分IP地址中的“网络部分”和“主机部分”。常见的子网掩码有：

- 255.255.255.0（对应/24，表示前24位是网络号，后8位是主机号）

举例说明：

- IP地址：192.168.1.100
- 子网掩码：255.255.255.0

这表示网络号是192.168.1，主机号是100。也就是说，192.168.1.0~192.168.1.255属于同一个局域网。

## 3.网关

**网关**（Gateway）是局域网中连接外部网络的设备（通常是路由器）。当本地设备要访问外网或其他网段时，数据会先发给网关，由网关转发到目标网络。

## 4.数据包
- **数据包**：网络中传输的数据会被分割成小包，每个包都包含源地址和目标地址，便于在网络中传递和重组。
## 5.端口
- **端口**：用于区分同一台设备上不同的服务，比如网页服务用80端口，SSH用22端口。端口实现了同一IP地址上多个服务的区分。
## 6.MAC地址
- **MAC地址**（Media Access Control Address）是网卡的物理地址，用于在局域网中唯一标识一台设备。MAC地址通常由6组16进制数表示，例如：00:1A:2B:3C:4D:5E。

---

## 三、TCP与UDP协议

网络通信主要依赖两种协议：**TCP**和**UDP**。这两个协议是构成互联网的基础，负责数据在网络中的传输。它们各有特点，适用于不同的场景。
![](/asset/tcp1.png)
### 1. TCP协议（Transmission Control Protocol）

- **面向连接**：通信前需要建立连接（三次握手）。
- **可靠传输**：保证数据不丢失、不重复、顺序到达。
- **适用场景**：对可靠性要求高的场景，如网页浏览、文件传输等。
- **缺点**：由于有连接管理和重传机制，速度相对较慢，开销较大。
  
### 2. UDP协议（User Datagram Protocol）

- **无连接**：发送数据前无需建立连接。
- **不保证可靠性**：数据可能丢失、乱序、重复。
- **适用场景**：对实时性要求高、可容忍丢包的场景，如视频直播、语音通话、DNS查询等。
- **优点**：速度快，开销小。

![](/asset/tcp2.png)
UDP协议就相当于是写信给对方，寄出去信件之后不能知道对方是否收到信件，信件内容是否完整，也不能得到及时反馈。

TCP协议就像是打电话通信，在这一系列流程都能得到及时反馈，并能确保对方及时接收到。
##### TCP三次握手详解

TCP协议在建立连接时，需要经过“三次握手”过程，确保通信双方都准备好进行数据传输。三次握手的具体步骤如下：

1. **第一次握手：客户端发送SYN**
   - 客户端向服务器发送一个带有SYN（同步）标志的数据包，表示请求建立连接。
   - 此时，客户端进入SYN_SEND状态。

2. **第二次握手：服务器回复SYN+ACK**
   - 服务器收到SYN包后，确认客户端请求，并向客户端发送一个带有SYN和ACK（确认）标志的数据包。
   - 其中，SYN表示同意建立连接，ACK表示确认收到客户端的SYN。
   - 服务器进入SYN_RCVD状态。

3. **第三次握手：客户端发送ACK**
   - 客户端收到服务器的SYN+ACK包后，再发送一个带有ACK标志的数据包给服务器，表示确认收到服务器的响应。
   - 发送完毕后，客户端和服务器都进入ESTABLISHED（已建立）状态，连接正式建立，可以开始数据传输。
![](/asset/tcp3.png)
**三次握手的目的**：
- 确认双方的发送和接收能力都正常。
- 防止历史连接请求包的干扰，保证连接的可靠性。

#### TCP与UDP对比表

| 特性   | TCP（打电话） | UDP（寄明信片） |
| ------ | ------------- | --------------- |
| 连接   | 需要          | 不需要          |
| 可靠性 | 可靠          | 不可靠          |
| 顺序   | 保证有序      | 不保证          |
| 速度   | 慢            | 快              |
| 开销   | 大            | 小              |

---

## 四、进程与线程的区别

在日常开发中，比如用C++写程序，通常会编译生成一个可执行文件。每当你运行这个可执行文件，操作系统就会为它分配一块独立的内存空间、打开文件描述符等资源，这就是一个**进程（Process）**。每个进程之间是相互隔离的，一个进程无法直接访问另一个进程的内存空间。

而**线程（Thread）**是进程内部的执行单元。一个进程可以包含一个或多个线程，这些线程本就共享来进程的内存和资源，所以想要实现数据共享十分简单，但每个线程有自己的栈空间和执行路径。线程之间切换速度快，适合处理并发任务，比如多窗口界面、并行计算等。

| 对比项   | 进程          | 线程             |
| -------- | ------------- | ---------------- |
| 地址空间 | 独立          | 共享             |
| 开销     | 大            | 小               |
| 通信     | 复杂（需IPC） | 简单（共享内存） |
| 并发性   | 一般          | 强               |

举个例子：你写了两个不同的C++程序，分别编译成两个可执行文件，运行后就是两个进程。它们各自独立，互不干扰。如果你希望这两个程序之间交换数据，就需要用到**进程间通信（IPC）**机制。而在同一个程序里，如果你用多线程技术（比如`std::thread`），这些线程可以直接访问同一块内存，通信和数据共享就非常方便。



---
## 五、IPC（进程间通信）方式详解

**IPC**（Inter-Process Communication）是操作系统为不同进程之间交换数据提供的机制。常见的IPC方式有：

- **无名管道（Pipe）**：单向通信，通常用于父子进程间，速度较快，但只能在有亲缘关系的进程间使用。
- **命名管道（FIFO）**：支持无亲缘关系进程间通信，适合在同一台主机上的不同进程间传递数据。
- **消息队列（Message Queue）**：以消息为单位进行通信，支持有序、异步传递，适合需要消息排队的场景。
- **共享内存（Shared Memory）**：多个进程可以访问同一块物理内存，速度最快，但需要配合同步机制（如信号量、互斥锁）防止数据竞争。
- **信号量（Semaphore）**：主要用于进程间同步，控制对共享资源的访问，常与共享内存配合使用。
- **信号（Signal）**：用于通知进程发生了某种事件，适合简单的事件通知。
- **套接字（Socket）**：不仅支持本地进程通信，还支持网络通信，是网络编程的基础。

---

## 六、Socket网络编程简介

**Socket**是应用层与传输层之间的编程接口。通过Socket，程序可以使用TCP或UDP协议进行数据收发。常用API包括：

- `socket()`：创建套接字
- `bind()`：绑定地址和端口
- `listen()`：监听连接（TCP）
- `accept()`：接受连接（TCP）
- `connect()`：发起连接
- `send()/recv()`：发送和接收数据
- `sendto()/recvfrom()`：UDP通信


![](/asset/socket.png)
Socket是实现网络通信的基础，无论是本地进程间通信还是跨网络通信，都可以通过Socket完成。

---


## 七、多线程编程
### std::thread 的基本用法

`std::thread` 是 C++11 标准库中用于创建和管理线程的类。常见用法如下：

```cpp
#include <iostream>
#include <thread>

void func(int id) {
    std::cout << "Thread " << id << " running\n";
}

int main() {
    std::thread t(func, 1); // 创建线程，执行func(1)

    if (t.joinable()) {     // 检查线程是否可被 join
        t.join();           // 等待线程执行完毕，主线程阻塞
    }

    std::cout << "Main thread finished\n";
    return 0;
}
```

#### 常用成员函数说明

- **join()**  
  等待线程执行结束，主线程会阻塞直到该线程运行完毕。每个线程只能被 join 一次。

- **joinable()**  
  判断线程对象是否可被 join 或 detach。只有线程对象管理着一个活动线程时才返回 true。

- **detach()**  
  将线程与线程对象分离，线程会在后台独立运行，主线程不会等待它结束。分离后不能再 join 或 detach，否则会抛出异常。

#### 注意事项

- 如果线程对象在析构前既没有被 join 也没有被 detach，会导致程序异常终止（std::terminate）。
- join 和 detach 只能二选一，且只能调用一次。

---


----
## 八、Mutex与线程竞争

当多个线程同时访问和修改同一个内存空间（如同一个变量）时，如果没有任何同步措施（比如加锁），就会发生**竞态条件（Race Condition）**。这是因为线程的执行顺序是不可预测的，可能出现以下问题：

- 一个线程刚读取了变量的值，还没来得及写回，另一个线程也读取并修改了同一个变量，导致最终结果不是预期的。
- 多个线程的读写操作交错进行，导致数据出现“脏读”或“丢失更新”。

举例说明：  
假设有两个线程同时对同一个整数变量`count`执行`count++`操作。这个操作实际上分为三步：读取count的值、加1、写回内存。如果两个线程同时执行，可能都读取到相同的旧值，分别加1后再写回，结果只增加了1而不是2。这就是线程竞争导致的数据不一致。

因此，在多线程环境下访问共享数据时，必须使用 **互斥锁（Mutex）** 等同步机制，保证同一时刻只有一个线程能操作该数据，避免竞态条件。
- 互斥锁相当于一把锁🔒，同一时刻只允许一个线程访问临界区。

### 互斥锁的基本用法（伪代码）

```c
mutex_lock(mutex);
// 临界区：访问共享数据
mutex_unlock(mutex);
```

